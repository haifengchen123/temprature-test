C51 COMPILER V9.56.0.0   DS18B20                                                           02/07/2021 07:23:33 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN .\Objects\ds18b20.obj
COMPILER INVOKED BY: C:\Keil_v5\MDK\C51\BIN\C51.EXE ds18b20.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\ds18b20.lst) TABS(2) OBJECT(.\Objects\ds18b20.obj)

line level    source

   1          
   2          #include <reg51.h>
   3          
   4          #include "delay.h"
   5          #include "timer.h"
   6          #include "uart.h"
   7          #include "led.h"
   8          
   9          #include "crc8.h"
  10          
  11          sbit  honey = P2^3;
  12          
  13          sbit  dq = P2^2;              //定义DQ引脚
  14          
  15          //初始化
  16          unsigned char ds18b20_init()
  17          { 
  18   1        unsigned char ret = 0;
  19   1       
  20   1        dq = 1;                     //主机先释放总线
  21   1        Delay5us();               
  22   1        dq = 0;                     //产生下降沿，用于通知DS18B20
  23   1        Delay500us() ;              //维持一段时间
  24   1        dq = 1;                     //主机释放总线，将控制权将DS18B20
  25   1        Delay100us();               //最多60us后，ds18b20即作出应答(持续时间：60~240)
  26   1        if(dq == 0)                 //主机读取DS18B20应答信号
  27   1          ret = 0;                      
  28   1        else
  29   1          ret = 0xff;                
  30   1        
  31   1        Delay500us();               //维持一段时间
  32   1        return ret;                 //返回应答结果
  33   1      }
  34          
  35          //向DS18B20发送一个字节
  36          void ds18b20_writeByte(unsigned char Dat)     
  37          {
  38   1        unsigned char i;
  39   1      
  40   1        for(i=0; i<8; i++)
  41   1        {
  42   2          dq = 1;         
  43   2          Delay5us();                 
  44   2          dq = 0;                   //起动信号
  45   2          Delay5us();               //等待一段时间（准备时间）
  46   2          if(Dat & 0x01)            //主机发数据
  47   2            dq = 1;                    
  48   2          else 
  49   2            dq = 0;                   
  50   2         
  51   2          Delay50us();              //等待一段时间，用于DS18B20接收数据
  52   2          Dat >>= 1;                //准备发下一位
  53   2        }
  54   1        dq = 1;                     //发送完毕，释放总线
C51 COMPILER V9.56.0.0   DS18B20                                                           02/07/2021 07:23:33 PAGE 2   

  55   1        Delay5us();               
  56   1      }
  57            
  58          
  59          //接收ds18b20返回的数据
  60          unsigned char ds18b20_readByte()
  61          {
  62   1        unsigned char i;
  63   1        unsigned char Dat = 0;
  64   1        
  65   1        for(i=0; i<8; i++)
  66   1        {
  67   2          Dat >>= 1;                //空出最高位，用于接收数据
  68   2          dq = 1;                   //主机释放总线
  69   2          Delay5us();        
  70   2          dq = 0;                   //起动信号
  71   2          Delay5us();       
  72   2          dq = 1;                   //主机释放总线，由ds18b20控制
  73   2          Delay5us(); 
  74   2          if(dq)                    //主机接收数据
  75   2            Dat |= 0X80;
  76   2          Delay50us();      
  77   2        }
  78   1        return Dat;
  79   1      }
  80          
  81          //定义缓冲区，用于保存接收的数据
  82          unsigned char ds18b20_buf[9]={0};
  83          //读DS18B2064位ROM值
  84          unsigned char ds18b20_readRomCode()         
  85          {
  86   1        unsigned char i = 0;
  87   1        unsigned char ret = 0;
  88   1        unsigned char crc = 0;
  89   1      
  90   1        ret = ds18b20_init();                   //初始化总线
  91   1        if(ret != 0)
  92   1          return 0xff;                    
  93   1        
  94   1        ds18b20_writeByte(0x33);                //发送ROM命令（0x33:读ROM，用于单节点）
  95   1        for(i=0;i<8;i++)                        //64位，接收8次
  96   1        {
  97   2          ds18b20_buf[i] =  ds18b20_readByte();//ds18b20_buf[0]:产品标号（0x28)
  98   2                                               //ds18b20_buf[6]-buf[1]:序列号
  99   2        }                                      //ds18b20_buf[8]:CRC校验码
 100   1        
 101   1        //用户可进行校验收到的数据
 102   1        crc = CRC8_LSB_Bytes(ds18b20_buf,7);    //校验
 103   1        if(crc == ds18b20_buf[7])
 104   1          return 0;                             //校验正确，返回0
 105   1        else 
 106   1          return 0xff;                          //校验不通过，返回0xff
 107   1      }
 108          
 109          
 110          //温度转换
 111          unsigned char ds18b20_ok = 0;           //转换完成标记
 112          unsigned char  ds18b20_start = 0;                  //开始转换标记
 113          unsigned int ds18b20_timeout = 0;               //用于记录转换超时时间
 114          
 115          unsigned char ds18b20_startTemConv()
 116          {
C51 COMPILER V9.56.0.0   DS18B20                                                           02/07/2021 07:23:33 PAGE 3   

 117   1        unsigned char ret = 0;
 118   1      
 119   1        ret = ds18b20_init();                                   //初始化总线 
 120   1        if(ret != 0)
 121   1          return 0xff;
 122   1        
 123   1        
 124   1        ds18b20_writeByte(0xcc);      //跳过ROM(用于单节点)
 125   1        ds18b20_writeByte(0x44);      //启动转换
 126   1        //转换时间用定时中断来实现，这样不影响数码管刷新
 127   1        ds18b20_timeout = 0;
 128   1        ds18b20_ok = 0;
 129   1        ds18b20_start = 1;            //用于同步定时器，使其开始计时
 130   1      
 131   1        return 0;
 132   1      }
 133          
 134          //读取缓冲区数据
 135          unsigned  char ds18b20_readBuffer()  
 136          {
 137   1        unsigned char i;  
 138   1        unsigned char ret = 0;
 139   1      
 140   1        ret = ds18b20_init();     
 141   1        if(ret != 0)
 142   1          return 0xff;
 143   1        ds18b20_writeByte(0xcc);                //跳过ROM
 144   1        ds18b20_writeByte(0xbe);                //读取全部缓冲区
 145   1        for(i=0; i<9; i++)                      //读数
 146   1        {
 147   2          ds18b20_buf[i] =  ds18b20_readByte(); //Tem[0/1]  :温度值
 148   2                                                //Tem[2/3]  :报警上下限值[2]是上限，[3]是下限
 149   2                                                //Tem[4]    :配置值
 150   2                                                //Tem[5/6/7] :保留                                                                 
             -                            
 151   2        }                                       //Tem[8]   :CRC校验值
 152   1      
 153   1        return 0;
 154   1      }
 155          
 156          //获取到温度值
 157          //在ds18b20_ok为1时，转换完成，可读取温度
 158          unsigned char ds18b20_readTemp(float *ptemp)   
 159          {
 160   1        unsigned char ret = 0xff;
 161   1        unsigned char crc = 0;
 162   1      
 163   1        ret = ds18b20_readBuffer();
 164   1        if(ret == 0xff)
 165   1            return 0xff; 
 166   1        else
 167   1        {
 168   2          //校验结果
 169   2          crc = CRC8_LSB_Bytes(ds18b20_buf,8);
 170   2          if(crc != ds18b20_buf[8])
 171   2            return 0xff;
 172   2          else
 173   2          {
 174   3            //温度数据格式：
 175   3            //高字节的高5位为符号位，为1则是负温度，为0则为正温度
 176   3            if(ds18b20_buf[1] & 0xf8)   //仅保留符号位，为1，负温度
 177   3               *ptemp = -((ds18b20_buf[1] & 0x07)<<8 | ds18b20_buf[0])*0.0625;//转换成小数
C51 COMPILER V9.56.0.0   DS18B20                                                           02/07/2021 07:23:33 PAGE 4   

 178   3            else
 179   3               *ptemp = ((ds18b20_buf[1] & 0x07)<<8 | ds18b20_buf[0])*0.0625; 
 180   3            
 181   3            return 0;
 182   3          }
 183   2        }
 184   1      }
 185          
 186          //写暂存器
 187          //TH_AlarmValue:温度报警上限
 188          //TL_AlarmValue:温度报警下限
 189          //ConfValue:配置值（用于配置精度）
 190          //配置字节格式：MSB                         LSB
 191          //                0  R1   R0  1   1   1   1   1
 192          //  R1R0:   00        9位精度，耗时93.75ms
 193          //          01        10位    耗时93.75x2 ms
 194          //          10        11位    93.75*4  ms
 195          //          11        12位    93.75*8  ms(750ms)
 196          //The factory default of these EEPROM bits is R0=1 and R1=1 (12-bit conversions)
 197          unsigned char ds18b20_writeBuffer(unsigned char TH_AlarmValue,unsigned char TL_AlarmValue,unsigned char Co
             -nfValue)
 198          {
 199   1        unsigned char ret = 0;
 200   1      
 201   1        ret = ds18b20_init();         //初始化总线 
 202   1        if(ret != 0)
 203   1          return 0xff;
 204   1        ds18b20_writeByte (0xcc);     //跳过ROM
 205   1        ds18b20_writeByte (0x4e);     //发送命令，用于写暂存器
 206   1        ds18b20_writeByte (TH_AlarmValue);    
 207   1        ds18b20_writeByte (TL_AlarmValue);    
 208   1        ds18b20_writeByte (ConfValue);        
 209   1      
 210   1        return 0;
 211   1      }
 212          
 213          
 214          //--------- 复制暂存器，将TH/TL/配置字节复制到EEPROM ---------------
 215          unsigned char DS18B20_CopyBuffer()
 216          {
 217   1        unsigned char ret = 0;
 218   1      
 219   1        ret = ds18b20_init();       
 220   1        if(ret != 0)
 221   1          return 0xff;
 222   1        ds18b20_writeByte (0xcc);     //跳过ROM
 223   1        ds18b20_writeByte (0x48);     //复制暂存器
 224   1        Delay2ms();               
 225   1        
 226   1        return 0;
 227   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    445    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.56.0.0   DS18B20                                                           02/07/2021 07:23:33 PAGE 5   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
