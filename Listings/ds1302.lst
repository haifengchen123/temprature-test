C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE DS1302
OBJECT MODULE PLACED IN .\Objects\ds1302.obj
COMPILER INVOKED BY: C:\Keil_v5\MDK\C51\BIN\C51.EXE ds1302.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\ds1302.lst) TABS(2) OBJECT(.\Objects\ds1302.obj)

line level    source

   1          
   2          #include <reg52.h>
   3          #include "delay.h"
   4          #include "ds1302.h"
   5          
   6          sbit ds1302_sclk = P2^1;
   7          sbit ds1302_sda = P2^0;       //注意：使用时，需用跳帽短接J15
   8          sbit ds1302_rst = P2^4;       //复位，在数据传输期间需拉高电平
   9          
  10          //数据在时钟上升沿输入，下降沿输出
  11          //控制指令
  12          /*
  13            bit7  bit6      bit5    bit4    bit3    bit2    bit1    bit0
  14            1     ram/#ck   a4      a3      a2      a1      a0      rd/#w
  15          
  16          bit6:ram/#ck    ：为1，用于操作RAM区，共31个字节
  17                          ：为0，用于操作时钟日历
  18          */
  19          
  20          void ds1302_init()
  21          {
  22   1        ds1302_rst = 0;
  23   1        ds1302_sclk = 0;
  24   1        ds1302_cancelProtect();   //取消写保护
  25   1        ds1302_start();           //起动走时
  26   1      }
  27          
  28          unsigned char ds1302_readClk(unsigned char addr)
  29          {
  30   1        unsigned char temp = 0,i = 0;
  31   1        
  32   1        ds1302_rst = 0;
  33   1        ds1302_sclk = 0;
  34   1        Delay5us();         //大于4us即可
  35   1        ds1302_rst = 1;     //由低到高，使能读写
  36   1        
  37   1        temp = addr<<1 | 0x81;    //RD=1,bit7=1
  38   1        for(i=0;i<8;i++)          //先写低位，发送地址
  39   1        {
  40   2          ds1302_sclk = 0;
  41   2          if(temp & 0x01)
  42   2            ds1302_sda = 1;
  43   2          else
  44   2            ds1302_sda = 0;
  45   2          ds1302_sclk = 1;        //提供上升沿，将数据发送出去
  46   2      
  47   2          temp>>=1;               //准备发送下一位
  48   2        }
  49   1        
  50   1        //读取数据
  51   1        temp = 0;                 //清零，准备接收读到的数，读前SDA = 1
  52   1        ds1302_sda = 1;
  53   1        
  54   1        for(i=0;i<8;i++)
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 2   

  55   1        {
  56   2          temp >>=1;                //空出最高位，准备接收（也可直接放置到对应位）
  57   2          ds1302_sclk = 0;        //产生下降沿，读取数据
  58   2          if(ds1302_sda == 1)
  59   2            temp |= 0x80;
  60   2          ds1302_sclk = 1;        //拉高时钟
  61   2        }
  62   1        ds1302_sclk = 0;  
  63   1      //  Delay5us();               //大于4us即可
  64   1        ds1302_rst = 0;     
  65   1        
  66   1        return temp;
  67   1      } 
  68          
  69          //写时钟
  70          unsigned char ds1302_writeClk(unsigned char addr,unsigned char dat)
  71          {
  72   1        unsigned char temp = 0,i = 0;
  73   1        
  74   1        ds1302_rst = 0;
  75   1        ds1302_sclk = 0;
  76   1        Delay5us();         //大于4us即可
  77   1        ds1302_rst = 1;     //由低到高，使能读写
  78   1        
  79   1        temp = addr<<1 | 0x81;    //RD=1,bit7=1
  80   1        for(i=0;i<8;i++)          //先写低位，发送地址
  81   1        {
  82   2          ds1302_sclk = 0;
  83   2          if(temp & 0x01)
  84   2            ds1302_sda = 1;
  85   2          else
  86   2            ds1302_sda = 0;
  87   2          ds1302_sclk = 1;        //提供上升沿，将数据发送出去
  88   2      
  89   2          temp>>=1;               //准备发送下一位
  90   2        }
  91   1        
  92   1        temp = dat;               //准备要发送的数据
  93   1        for(i=0;i<8;i++)
  94   1        {
  95   2          ds1302_sclk = 0;
  96   2          if(temp & 0x01)
  97   2            ds1302_sda = 1;
  98   2          else
  99   2            ds1302_sda = 0;
 100   2          ds1302_sclk = 1;        //提供上升沿，将数据发送出去
 101   2      
 102   2          temp>>=1;               //准备发送下一位
 103   2        }
 104   1        ds1302_sclk = 0;  
 105   1      //  Delay5us();             //大于4us即可
 106   1        ds1302_rst = 0;     
 107   1        
 108   1        return temp;
 109   1      }
 110          
 111          //读RAM
 112          unsigned char ds1302_readRam(unsigned char addr)
 113          {
 114   1        unsigned char temp = 0,i = 0;
 115   1        
 116   1        ds1302_rst = 0;
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 3   

 117   1        ds1302_sclk = 0;
 118   1        Delay5us();         //大于4us即可
 119   1        ds1302_rst = 1;     //由低到高，使能读写
 120   1        
 121   1        temp = addr<<1 | 0xc1;    //RD=1,bit7=1,bit6=1
 122   1        for(i=0;i<8;i++)          //先写低位，发送地址
 123   1        {
 124   2          ds1302_sclk = 0;
 125   2          if(temp & 0x01)
 126   2            ds1302_sda = 1;
 127   2          else
 128   2            ds1302_sda = 0;
 129   2          ds1302_sclk = 1;        //提供上升沿，将数据发送出去
 130   2      
 131   2          temp>>=1;               //准备发送下一位
 132   2        }
 133   1        
 134   1        //读取数据
 135   1        temp = 0;                 //清零，准备接收读到的数，读前SDA = 1
 136   1        ds1302_sda = 1;
 137   1        
 138   1        for(i=0;i<8;i++)
 139   1        {
 140   2          temp >>=1;                //空出最高位，准备接收（也可直接放置到对应位）
 141   2          ds1302_sclk = 0;          //产生下降沿，读取数据
 142   2          if(ds1302_sda == 1)
 143   2            temp |= 0x80;
 144   2          ds1302_sclk = 1;        //拉高时钟
 145   2        }
 146   1        ds1302_sclk = 0;  
 147   1      //  Delay5us();               //大于4us即可
 148   1        ds1302_rst = 0;     
 149   1        
 150   1        return temp;
 151   1      } 
 152          
 153          //写RAM
 154          unsigned char ds1302_writeRam(unsigned char addr,unsigned char dat)
 155          {
 156   1        unsigned char temp = 0,i = 0;
 157   1        
 158   1        ds1302_rst = 0;
 159   1        ds1302_sclk = 0;
 160   1        Delay5us();         //大于4us即可
 161   1        ds1302_rst = 1;     //由低到高，使能读写
 162   1        
 163   1        temp = addr<<1 | 0xc1;    //RD=1,bit7=1
 164   1        for(i=0;i<8;i++)          //先写低位，发送地址
 165   1        {
 166   2          ds1302_sclk = 0;
 167   2          if(temp & 0x01)
 168   2            ds1302_sda = 1;
 169   2          else
 170   2            ds1302_sda = 0;
 171   2          ds1302_sclk = 1;        //提供上升沿，将数据发送出去
 172   2      
 173   2          temp>>=1;               //准备发送下一位
 174   2        }
 175   1        
 176   1        temp = dat;               //准备要发送的数据
 177   1        for(i=0;i<8;i++)
 178   1        {
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 4   

 179   2          ds1302_sclk = 0;
 180   2          if(temp & 0x01)
 181   2            ds1302_sda = 1;
 182   2          else
 183   2            ds1302_sda = 0;
 184   2          ds1302_sclk = 1;        //提供上升沿，将数据发送出去
 185   2      
 186   2          temp>>=1;               //准备发送下一位
 187   2        }
 188   1        ds1302_sclk = 0;  
 189   1      //  Delay5us();             //大于4us即可
 190   1        ds1302_rst = 0;     
 191   1        
 192   1        return temp;
 193   1      }
 194          
 195          //时钟寄存器中数据存储格式为BCD码
 196          unsigned char  bcd2dec(unsigned char bcd)
 197          {
 198   1        unsigned char dec = 0;
 199   1        
 200   1        dec = (bcd>>4)*10 + (bcd & 0x0f);
 201   1        
 202   1        return dec;
 203   1      }
 204          
 205          unsigned char  dec2bcd(unsigned char dec)
 206          {
 207   1        unsigned char bcd = 0;
 208   1        
 209   1        bcd = ((dec/10)<<4 ) | (dec%10);
 210   1      
 211   1        return bcd;
 212   1      }
 213          
 214          
 215          //秒的读、写
 216          unsigned char ds1302_readSec()
 217          {
 218   1        unsigned char temp = 0;
 219   1        
 220   1        temp = ds1302_readClk(ADDR_SEC);
 221   1        temp &= 0x7f;           //最高位是停止位，屏蔽掉
 222   1        
 223   1        temp = bcd2dec(temp);   //转成10进制
 224   1        return temp;            
 225   1      }
 226          
 227          //写秒
 228          void ds1302_writeSec(unsigned char sec)
 229          {
 230   1        sec %= 60;      //限制取值：0~59
 231   1        sec = dec2bcd(sec); //转bcd
 232   1        ds1302_writeClk(ADDR_SEC,sec);
 233   1      }
 234          
 235          //停止DS1302
 236          void ds1302_stop(void)
 237          {
 238   1        unsigned char temp = 0;
 239   1        
 240   1        temp = ds1302_readClk(ADDR_SEC);
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 5   

 241   1        temp |= 0x80;
 242   1        ds1302_writeClk(ADDR_SEC,temp);
 243   1      }
 244          
 245          //起动ds1302
 246          void ds1302_start(void)
 247          {
 248   1        unsigned char temp = 0;
 249   1        
 250   1        temp = ds1302_readClk(ADDR_SEC);
 251   1        temp &= 0x7f;
 252   1        ds1302_writeClk(ADDR_SEC,temp);
 253   1      }
 254          
 255          //读分
 256          unsigned char ds1302_readMin()
 257          {
 258   1        unsigned char temp = 0;
 259   1        
 260   1        temp = ds1302_readClk(ADDR_MIN);
 261   1        temp = bcd2dec(temp);   //转成10进制
 262   1        return temp;            
 263   1      }
 264          
 265          //写分
 266          void ds1302_writeMin(unsigned char min)
 267          {
 268   1        min %= 60;      //限制取值：0~59
 269   1        min = dec2bcd(min); //转bcd
 270   1        ds1302_writeClk(ADDR_MIN,min);
 271   1      }
 272          
 273          //这里采用24小时制
 274          //读时
 275          //读分
 276          unsigned char ds1302_readHour()
 277          {
 278   1        unsigned char temp = 0;
 279   1        
 280   1        temp = ds1302_readClk(ADDR_HR);
 281   1        temp &= 0x3f;                     //只要低6位
 282   1        temp = bcd2dec(temp);             //转成10进制
 283   1        return temp;            
 284   1      }
 285          
 286          //写时
 287          void ds1302_writeHour(unsigned char hour)
 288          {
 289   1        hour %= 24;     //限制取值：0~23
 290   1        hour = dec2bcd(hour); //转bcd
 291   1        ds1302_writeClk(ADDR_HR,hour);
 292   1      }
 293          
 294          
 295          //读日期
 296          unsigned char ds1302_readDate()
 297          {
 298   1        unsigned char temp = 0;
 299   1        
 300   1        temp = ds1302_readClk(ADDR_DATE);
 301   1        temp &= 0x3f;                     //只要低6位
 302   1        temp = bcd2dec(temp);             //转成10进制
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 6   

 303   1        return temp;            
 304   1      }
 305          
 306          
 307          //写日期
 308          unsigned char ds1302_writeDate(unsigned char date)
 309          {
 310   1        unsigned char temp = 0;
 311   1        
 312   1        temp = ds1302_readClk(ADDR_MONTH);      //先读月份，根据月份限制参数取值范围
 313   1        temp = bcd2dec(temp);
 314   1        switch(temp)
 315   1        {
 316   2          case 1:   //1~31天
 317   2          case 3:
 318   2          case 5:
 319   2          case 7:
 320   2          case 8:
 321   2          case 10:
 322   2          case 12:
 323   2            if(date > 31 || date < 1)
 324   2              temp = 0xff;
 325   2            break;
 326   2          case 2:
 327   2              temp = ds1302_readClk(ADDR_YEAR);
 328   2              temp = bcd2dec(temp);
 329   2              if((temp%4==0  && temp%100 != 0) || temp%400 == 0)    //闰年
 330   2              {
 331   3                if(date<1 || date>29)   //闰年，不能超29
 332   3                  temp = 0xff;
 333   3              }
 334   2              else
 335   2              {
 336   3                if(date<1 || date>28)
 337   3                  temp = 0xff;
 338   3              }
 339   2            break;
 340   2          case 4:
 341   2          case 6:
 342   2          case 9:
 343   2          case 11:
 344   2            if(date>30 || date<1)
 345   2              temp = 0xff;
 346   2            break;
 347   2        }
 348   1        
 349   1        if(temp != 0xff)
 350   1        {
 351   2          date = dec2bcd(date);
 352   2          ds1302_writeClk(ADDR_DATE,date);
 353   2          temp = 0;                               //成功写入
 354   2        }
 355   1        
 356   1        return temp;            
 357   1      }
 358          
 359          //读月份
 360          unsigned char ds1302_readMonth()
 361          {
 362   1        unsigned char temp = 0;
 363   1        
 364   1        temp = ds1302_readClk(ADDR_MONTH);
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 7   

 365   1        temp &= 0x1f;
 366   1        temp = bcd2dec(temp);
 367   1        
 368   1        return temp;
 369   1      }
 370          
 371          //写月份
 372          unsigned char ds1302_writeMonth(unsigned char month)
 373          {
 374   1        unsigned char temp = 0;
 375   1        
 376   1        if(month<1 || month>12)
 377   1          temp = 0xff;
 378   1        else
 379   1        {
 380   2          month = dec2bcd(month);
 381   2          ds1302_writeClk(ADDR_MONTH,month);
 382   2        }
 383   1          
 384   1        return temp;
 385   1      }
 386          
 387          
 388          //读星期
 389          unsigned char ds1302_readDay()
 390          {
 391   1        unsigned char temp = 0;
 392   1        
 393   1        temp = ds1302_readClk(ADDR_DAY);
 394   1        temp &= 0x07;
 395   1        temp = bcd2dec(temp);
 396   1        
 397   1        return temp;
 398   1      }
 399          
 400          //写星期
 401          unsigned char ds1302_writeDay(unsigned char day)
 402          {
 403   1        unsigned char temp = 0;
 404   1        
 405   1        if(day<1 || day>7)
 406   1          temp = 0xff;
 407   1        else
 408   1        {
 409   2          day = dec2bcd(day);
 410   2          ds1302_writeClk(ADDR_DAY,day);
 411   2        }
 412   1          
 413   1        return temp;
 414   1      }
 415          
 416          //读年
 417          unsigned char ds1302_readYear()
 418          {
 419   1        unsigned char temp = 0;
 420   1        
 421   1        temp = ds1302_readClk(ADDR_YEAR);
 422   1        temp = bcd2dec(temp);
 423   1        
 424   1        return temp;
 425   1      }
 426          
C51 COMPILER V9.56.0.0   DS1302                                                            02/07/2021 06:57:52 PAGE 8   

 427          //写年
 428          unsigned char ds1302_writeYear(unsigned char year)
 429          {
 430   1        unsigned char temp = 0;
 431   1        
 432   1        if(year>99)
 433   1          temp = 0xff;
 434   1        else
 435   1        {
 436   2          year = dec2bcd(year);
 437   2          ds1302_writeClk(ADDR_YEAR,year);
 438   2        }
 439   1          
 440   1        return temp;
 441   1      }
 442          
 443          //写保护
 444          void ds1302_writeProtect()
 445          { 
 446   1        ds1302_writeClk(ADDR_CTRL,0x80);  //最高位写1
 447   1      }
 448          
 449          //取消写保护
 450          void ds1302_cancelProtect()
 451          {           
 452   1        ds1302_writeClk(ADDR_CTRL,0);
 453   1      }
 454          
 455          
 456          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    831    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
